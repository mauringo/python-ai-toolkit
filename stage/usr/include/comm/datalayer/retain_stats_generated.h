// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_RETAINSTATS_COMM_DATALAYER_H_
#define FLATBUFFERS_GENERATED_RETAINSTATS_COMM_DATALAYER_H_

#include "flatbuffers/flatbuffers.h"

namespace comm {
namespace datalayer {

struct RetainStats;
struct RetainStatsBuilder;
struct RetainStatsT;

struct RetainStatsT : public flatbuffers::NativeTable {
  typedef RetainStats TableType;
  uint32_t total = 0;
  uint32_t free = 0;
  uint32_t used = 0;
  uint32_t biggestFree = 0;
  uint32_t syncCounter = 0;
  uint32_t lastUsed = 0;
  std::string info{};
};

struct RetainStats FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RetainStatsT NativeTableType;
  typedef RetainStatsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TOTAL = 4,
    VT_FREE = 6,
    VT_USED = 8,
    VT_BIGGESTFREE = 10,
    VT_SYNCCOUNTER = 12,
    VT_LASTUSED = 14,
    VT_INFO = 16
  };
  uint32_t total() const {
    return GetField<uint32_t>(VT_TOTAL, 0);
  }
  bool mutate_total(uint32_t _total) {
    return SetField<uint32_t>(VT_TOTAL, _total, 0);
  }
  uint32_t free() const {
    return GetField<uint32_t>(VT_FREE, 0);
  }
  bool mutate_free(uint32_t _free) {
    return SetField<uint32_t>(VT_FREE, _free, 0);
  }
  uint32_t used() const {
    return GetField<uint32_t>(VT_USED, 0);
  }
  bool mutate_used(uint32_t _used) {
    return SetField<uint32_t>(VT_USED, _used, 0);
  }
  uint32_t biggestFree() const {
    return GetField<uint32_t>(VT_BIGGESTFREE, 0);
  }
  bool mutate_biggestFree(uint32_t _biggestFree) {
    return SetField<uint32_t>(VT_BIGGESTFREE, _biggestFree, 0);
  }
  uint32_t syncCounter() const {
    return GetField<uint32_t>(VT_SYNCCOUNTER, 0);
  }
  bool mutate_syncCounter(uint32_t _syncCounter) {
    return SetField<uint32_t>(VT_SYNCCOUNTER, _syncCounter, 0);
  }
  uint32_t lastUsed() const {
    return GetField<uint32_t>(VT_LASTUSED, 0);
  }
  bool mutate_lastUsed(uint32_t _lastUsed) {
    return SetField<uint32_t>(VT_LASTUSED, _lastUsed, 0);
  }
  const flatbuffers::String *info() const {
    return GetPointer<const flatbuffers::String *>(VT_INFO);
  }
  flatbuffers::String *mutable_info() {
    return GetPointer<flatbuffers::String *>(VT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_TOTAL) &&
           VerifyField<uint32_t>(verifier, VT_FREE) &&
           VerifyField<uint32_t>(verifier, VT_USED) &&
           VerifyField<uint32_t>(verifier, VT_BIGGESTFREE) &&
           VerifyField<uint32_t>(verifier, VT_SYNCCOUNTER) &&
           VerifyField<uint32_t>(verifier, VT_LASTUSED) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyString(info()) &&
           verifier.EndTable();
  }
  RetainStatsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RetainStatsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<RetainStats> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RetainStatsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RetainStatsBuilder {
  typedef RetainStats Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_total(uint32_t total) {
    fbb_.AddElement<uint32_t>(RetainStats::VT_TOTAL, total, 0);
  }
  void add_free(uint32_t free) {
    fbb_.AddElement<uint32_t>(RetainStats::VT_FREE, free, 0);
  }
  void add_used(uint32_t used) {
    fbb_.AddElement<uint32_t>(RetainStats::VT_USED, used, 0);
  }
  void add_biggestFree(uint32_t biggestFree) {
    fbb_.AddElement<uint32_t>(RetainStats::VT_BIGGESTFREE, biggestFree, 0);
  }
  void add_syncCounter(uint32_t syncCounter) {
    fbb_.AddElement<uint32_t>(RetainStats::VT_SYNCCOUNTER, syncCounter, 0);
  }
  void add_lastUsed(uint32_t lastUsed) {
    fbb_.AddElement<uint32_t>(RetainStats::VT_LASTUSED, lastUsed, 0);
  }
  void add_info(flatbuffers::Offset<flatbuffers::String> info) {
    fbb_.AddOffset(RetainStats::VT_INFO, info);
  }
  explicit RetainStatsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<RetainStats> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RetainStats>(end);
    return o;
  }
};

inline flatbuffers::Offset<RetainStats> CreateRetainStats(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t total = 0,
    uint32_t free = 0,
    uint32_t used = 0,
    uint32_t biggestFree = 0,
    uint32_t syncCounter = 0,
    uint32_t lastUsed = 0,
    flatbuffers::Offset<flatbuffers::String> info = 0) {
  RetainStatsBuilder builder_(_fbb);
  builder_.add_info(info);
  builder_.add_lastUsed(lastUsed);
  builder_.add_syncCounter(syncCounter);
  builder_.add_biggestFree(biggestFree);
  builder_.add_used(used);
  builder_.add_free(free);
  builder_.add_total(total);
  return builder_.Finish();
}

inline flatbuffers::Offset<RetainStats> CreateRetainStatsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t total = 0,
    uint32_t free = 0,
    uint32_t used = 0,
    uint32_t biggestFree = 0,
    uint32_t syncCounter = 0,
    uint32_t lastUsed = 0,
    const char *info = nullptr) {
  auto info__ = info ? _fbb.CreateString(info) : 0;
  return comm::datalayer::CreateRetainStats(
      _fbb,
      total,
      free,
      used,
      biggestFree,
      syncCounter,
      lastUsed,
      info__);
}

flatbuffers::Offset<RetainStats> CreateRetainStats(flatbuffers::FlatBufferBuilder &_fbb, const RetainStatsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RetainStatsT *RetainStats::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RetainStatsT>(new RetainStatsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void RetainStats::UnPackTo(RetainStatsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = total(); _o->total = _e; }
  { auto _e = free(); _o->free = _e; }
  { auto _e = used(); _o->used = _e; }
  { auto _e = biggestFree(); _o->biggestFree = _e; }
  { auto _e = syncCounter(); _o->syncCounter = _e; }
  { auto _e = lastUsed(); _o->lastUsed = _e; }
  { auto _e = info(); if (_e) _o->info = _e->str(); }
}

inline flatbuffers::Offset<RetainStats> RetainStats::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RetainStatsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRetainStats(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<RetainStats> CreateRetainStats(flatbuffers::FlatBufferBuilder &_fbb, const RetainStatsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RetainStatsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _total = _o->total;
  auto _free = _o->free;
  auto _used = _o->used;
  auto _biggestFree = _o->biggestFree;
  auto _syncCounter = _o->syncCounter;
  auto _lastUsed = _o->lastUsed;
  auto _info = _o->info.empty() ? 0 : _fbb.CreateString(_o->info);
  return comm::datalayer::CreateRetainStats(
      _fbb,
      _total,
      _free,
      _used,
      _biggestFree,
      _syncCounter,
      _lastUsed,
      _info);
}

inline const comm::datalayer::RetainStats *GetRetainStats(const void *buf) {
  return flatbuffers::GetRoot<comm::datalayer::RetainStats>(buf);
}

inline const comm::datalayer::RetainStats *GetSizePrefixedRetainStats(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<comm::datalayer::RetainStats>(buf);
}

inline RetainStats *GetMutableRetainStats(void *buf) {
  return flatbuffers::GetMutableRoot<RetainStats>(buf);
}

inline bool VerifyRetainStatsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<comm::datalayer::RetainStats>(nullptr);
}

inline bool VerifySizePrefixedRetainStatsBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<comm::datalayer::RetainStats>(nullptr);
}

inline void FinishRetainStatsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<comm::datalayer::RetainStats> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRetainStatsBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<comm::datalayer::RetainStats> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<comm::datalayer::RetainStatsT> UnPackRetainStats(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::RetainStatsT>(GetRetainStats(buf)->UnPack(res));
}

inline std::unique_ptr<comm::datalayer::RetainStatsT> UnPackSizePrefixedRetainStats(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::RetainStatsT>(GetSizePrefixedRetainStats(buf)->UnPack(res));
}

}  // namespace datalayer
}  // namespace comm

#endif  // FLATBUFFERS_GENERATED_RETAINSTATS_COMM_DATALAYER_H_
