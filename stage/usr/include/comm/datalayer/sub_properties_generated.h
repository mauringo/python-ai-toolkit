// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SUBPROPERTIES_COMM_DATALAYER_H_
#define FLATBUFFERS_GENERATED_SUBPROPERTIES_COMM_DATALAYER_H_

#include "flatbuffers/flatbuffers.h"

namespace comm {
namespace datalayer {

struct Sampling;
struct SamplingBuilder;
struct SamplingT;

struct Queueing;
struct QueueingBuilder;
struct QueueingT;

struct DataChangeFilter;
struct DataChangeFilterBuilder;
struct DataChangeFilterT;

struct ChangeEvents;
struct ChangeEventsBuilder;
struct ChangeEventsT;

struct Counting;
struct CountingBuilder;
struct CountingT;

struct Property;
struct PropertyBuilder;
struct PropertyT;

struct SubscriptionProperties;
struct SubscriptionPropertiesBuilder;
struct SubscriptionPropertiesT;

enum QueueBehaviour : int32_t {
  QueueBehaviour_DiscardOldest = 0,
  QueueBehaviour_DiscardNewest = 1,
  QueueBehaviour_MIN = QueueBehaviour_DiscardOldest,
  QueueBehaviour_MAX = QueueBehaviour_DiscardNewest
};

inline const QueueBehaviour (&EnumValuesQueueBehaviour())[2] {
  static const QueueBehaviour values[] = {
    QueueBehaviour_DiscardOldest,
    QueueBehaviour_DiscardNewest
  };
  return values;
}

inline const char * const *EnumNamesQueueBehaviour() {
  static const char * const names[3] = {
    "DiscardOldest",
    "DiscardNewest",
    nullptr
  };
  return names;
}

inline const char *EnumNameQueueBehaviour(QueueBehaviour e) {
  if (flatbuffers::IsOutRange(e, QueueBehaviour_DiscardOldest, QueueBehaviour_DiscardNewest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQueueBehaviour()[index];
}

enum DataChangeTrigger : int32_t {
  DataChangeTrigger_Status = 0,
  DataChangeTrigger_StatusValue = 1,
  DataChangeTrigger_StatusValueTimestamp = 2,
  DataChangeTrigger_MIN = DataChangeTrigger_Status,
  DataChangeTrigger_MAX = DataChangeTrigger_StatusValueTimestamp
};

inline const DataChangeTrigger (&EnumValuesDataChangeTrigger())[3] {
  static const DataChangeTrigger values[] = {
    DataChangeTrigger_Status,
    DataChangeTrigger_StatusValue,
    DataChangeTrigger_StatusValueTimestamp
  };
  return values;
}

inline const char * const *EnumNamesDataChangeTrigger() {
  static const char * const names[4] = {
    "Status",
    "StatusValue",
    "StatusValueTimestamp",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataChangeTrigger(DataChangeTrigger e) {
  if (flatbuffers::IsOutRange(e, DataChangeTrigger_Status, DataChangeTrigger_StatusValueTimestamp)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataChangeTrigger()[index];
}

enum Properties : uint8_t {
  Properties_NONE = 0,
  Properties_Sampling = 1,
  Properties_Queueing = 2,
  Properties_DataChangeFilter = 3,
  Properties_ChangeEvents = 4,
  Properties_Counting = 5,
  Properties_MIN = Properties_NONE,
  Properties_MAX = Properties_Counting
};

inline const Properties (&EnumValuesProperties())[6] {
  static const Properties values[] = {
    Properties_NONE,
    Properties_Sampling,
    Properties_Queueing,
    Properties_DataChangeFilter,
    Properties_ChangeEvents,
    Properties_Counting
  };
  return values;
}

inline const char * const *EnumNamesProperties() {
  static const char * const names[7] = {
    "NONE",
    "Sampling",
    "Queueing",
    "DataChangeFilter",
    "ChangeEvents",
    "Counting",
    nullptr
  };
  return names;
}

inline const char *EnumNameProperties(Properties e) {
  if (flatbuffers::IsOutRange(e, Properties_NONE, Properties_Counting)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProperties()[index];
}

template<typename T> struct PropertiesTraits {
  static const Properties enum_value = Properties_NONE;
};

template<> struct PropertiesTraits<comm::datalayer::Sampling> {
  static const Properties enum_value = Properties_Sampling;
};

template<> struct PropertiesTraits<comm::datalayer::Queueing> {
  static const Properties enum_value = Properties_Queueing;
};

template<> struct PropertiesTraits<comm::datalayer::DataChangeFilter> {
  static const Properties enum_value = Properties_DataChangeFilter;
};

template<> struct PropertiesTraits<comm::datalayer::ChangeEvents> {
  static const Properties enum_value = Properties_ChangeEvents;
};

template<> struct PropertiesTraits<comm::datalayer::Counting> {
  static const Properties enum_value = Properties_Counting;
};

struct PropertiesUnion {
  Properties type;
  void *value;

  PropertiesUnion() : type(Properties_NONE), value(nullptr) {}
  PropertiesUnion(PropertiesUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Properties_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  PropertiesUnion(const PropertiesUnion &);
  PropertiesUnion &operator=(const PropertiesUnion &u)
    { PropertiesUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  PropertiesUnion &operator=(PropertiesUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~PropertiesUnion() { Reset(); }

  void Reset();

#ifndef FLATBUFFERS_CPP98_STL
  template <typename T>
  void Set(T&& val) {
    using RT = typename std::remove_reference<T>::type;
    Reset();
    type = PropertiesTraits<typename RT::TableType>::enum_value;
    if (type != Properties_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }
#endif  // FLATBUFFERS_CPP98_STL

  static void *UnPack(const void *obj, Properties type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  comm::datalayer::SamplingT *AsSampling() {
    return type == Properties_Sampling ?
      reinterpret_cast<comm::datalayer::SamplingT *>(value) : nullptr;
  }
  const comm::datalayer::SamplingT *AsSampling() const {
    return type == Properties_Sampling ?
      reinterpret_cast<const comm::datalayer::SamplingT *>(value) : nullptr;
  }
  comm::datalayer::QueueingT *AsQueueing() {
    return type == Properties_Queueing ?
      reinterpret_cast<comm::datalayer::QueueingT *>(value) : nullptr;
  }
  const comm::datalayer::QueueingT *AsQueueing() const {
    return type == Properties_Queueing ?
      reinterpret_cast<const comm::datalayer::QueueingT *>(value) : nullptr;
  }
  comm::datalayer::DataChangeFilterT *AsDataChangeFilter() {
    return type == Properties_DataChangeFilter ?
      reinterpret_cast<comm::datalayer::DataChangeFilterT *>(value) : nullptr;
  }
  const comm::datalayer::DataChangeFilterT *AsDataChangeFilter() const {
    return type == Properties_DataChangeFilter ?
      reinterpret_cast<const comm::datalayer::DataChangeFilterT *>(value) : nullptr;
  }
  comm::datalayer::ChangeEventsT *AsChangeEvents() {
    return type == Properties_ChangeEvents ?
      reinterpret_cast<comm::datalayer::ChangeEventsT *>(value) : nullptr;
  }
  const comm::datalayer::ChangeEventsT *AsChangeEvents() const {
    return type == Properties_ChangeEvents ?
      reinterpret_cast<const comm::datalayer::ChangeEventsT *>(value) : nullptr;
  }
  comm::datalayer::CountingT *AsCounting() {
    return type == Properties_Counting ?
      reinterpret_cast<comm::datalayer::CountingT *>(value) : nullptr;
  }
  const comm::datalayer::CountingT *AsCounting() const {
    return type == Properties_Counting ?
      reinterpret_cast<const comm::datalayer::CountingT *>(value) : nullptr;
  }
};

bool VerifyProperties(flatbuffers::Verifier &verifier, const void *obj, Properties type);
bool VerifyPropertiesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct SamplingT : public flatbuffers::NativeTable {
  typedef Sampling TableType;
  uint64_t samplingInterval = 1000000ULL;
};

struct Sampling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SamplingT NativeTableType;
  typedef SamplingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SAMPLINGINTERVAL = 4
  };
  uint64_t samplingInterval() const {
    return GetField<uint64_t>(VT_SAMPLINGINTERVAL, 1000000ULL);
  }
  bool mutate_samplingInterval(uint64_t _samplingInterval) {
    return SetField<uint64_t>(VT_SAMPLINGINTERVAL, _samplingInterval, 1000000ULL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SAMPLINGINTERVAL) &&
           verifier.EndTable();
  }
  SamplingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SamplingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Sampling> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SamplingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SamplingBuilder {
  typedef Sampling Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_samplingInterval(uint64_t samplingInterval) {
    fbb_.AddElement<uint64_t>(Sampling::VT_SAMPLINGINTERVAL, samplingInterval, 1000000ULL);
  }
  explicit SamplingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Sampling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sampling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sampling> CreateSampling(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t samplingInterval = 1000000ULL) {
  SamplingBuilder builder_(_fbb);
  builder_.add_samplingInterval(samplingInterval);
  return builder_.Finish();
}

flatbuffers::Offset<Sampling> CreateSampling(flatbuffers::FlatBufferBuilder &_fbb, const SamplingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct QueueingT : public flatbuffers::NativeTable {
  typedef Queueing TableType;
  uint32_t queueSize = 10;
  comm::datalayer::QueueBehaviour behaviour = comm::datalayer::QueueBehaviour_DiscardOldest;
};

struct Queueing FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QueueingT NativeTableType;
  typedef QueueingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_QUEUESIZE = 4,
    VT_BEHAVIOUR = 6
  };
  uint32_t queueSize() const {
    return GetField<uint32_t>(VT_QUEUESIZE, 10);
  }
  bool mutate_queueSize(uint32_t _queueSize) {
    return SetField<uint32_t>(VT_QUEUESIZE, _queueSize, 10);
  }
  comm::datalayer::QueueBehaviour behaviour() const {
    return static_cast<comm::datalayer::QueueBehaviour>(GetField<int32_t>(VT_BEHAVIOUR, 0));
  }
  bool mutate_behaviour(comm::datalayer::QueueBehaviour _behaviour) {
    return SetField<int32_t>(VT_BEHAVIOUR, static_cast<int32_t>(_behaviour), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_QUEUESIZE) &&
           VerifyField<int32_t>(verifier, VT_BEHAVIOUR) &&
           verifier.EndTable();
  }
  QueueingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QueueingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Queueing> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueueingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QueueingBuilder {
  typedef Queueing Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_queueSize(uint32_t queueSize) {
    fbb_.AddElement<uint32_t>(Queueing::VT_QUEUESIZE, queueSize, 10);
  }
  void add_behaviour(comm::datalayer::QueueBehaviour behaviour) {
    fbb_.AddElement<int32_t>(Queueing::VT_BEHAVIOUR, static_cast<int32_t>(behaviour), 0);
  }
  explicit QueueingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Queueing> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Queueing>(end);
    return o;
  }
};

inline flatbuffers::Offset<Queueing> CreateQueueing(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t queueSize = 10,
    comm::datalayer::QueueBehaviour behaviour = comm::datalayer::QueueBehaviour_DiscardOldest) {
  QueueingBuilder builder_(_fbb);
  builder_.add_behaviour(behaviour);
  builder_.add_queueSize(queueSize);
  return builder_.Finish();
}

flatbuffers::Offset<Queueing> CreateQueueing(flatbuffers::FlatBufferBuilder &_fbb, const QueueingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct DataChangeFilterT : public flatbuffers::NativeTable {
  typedef DataChangeFilter TableType;
  float deadBandValue = 0.0f;
};

struct DataChangeFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DataChangeFilterT NativeTableType;
  typedef DataChangeFilterBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEADBANDVALUE = 4
  };
  float deadBandValue() const {
    return GetField<float>(VT_DEADBANDVALUE, 0.0f);
  }
  bool mutate_deadBandValue(float _deadBandValue) {
    return SetField<float>(VT_DEADBANDVALUE, _deadBandValue, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_DEADBANDVALUE) &&
           verifier.EndTable();
  }
  DataChangeFilterT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DataChangeFilterT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<DataChangeFilter> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataChangeFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DataChangeFilterBuilder {
  typedef DataChangeFilter Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_deadBandValue(float deadBandValue) {
    fbb_.AddElement<float>(DataChangeFilter::VT_DEADBANDVALUE, deadBandValue, 0.0f);
  }
  explicit DataChangeFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<DataChangeFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DataChangeFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<DataChangeFilter> CreateDataChangeFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    float deadBandValue = 0.0f) {
  DataChangeFilterBuilder builder_(_fbb);
  builder_.add_deadBandValue(deadBandValue);
  return builder_.Finish();
}

flatbuffers::Offset<DataChangeFilter> CreateDataChangeFilter(flatbuffers::FlatBufferBuilder &_fbb, const DataChangeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ChangeEventsT : public flatbuffers::NativeTable {
  typedef ChangeEvents TableType;
  comm::datalayer::DataChangeTrigger valueChange = comm::datalayer::DataChangeTrigger_StatusValue;
  bool browselistChange = false;
  bool metadataChange = false;
};

struct ChangeEvents FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ChangeEventsT NativeTableType;
  typedef ChangeEventsBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUECHANGE = 4,
    VT_BROWSELISTCHANGE = 6,
    VT_METADATACHANGE = 8
  };
  comm::datalayer::DataChangeTrigger valueChange() const {
    return static_cast<comm::datalayer::DataChangeTrigger>(GetField<int32_t>(VT_VALUECHANGE, 1));
  }
  bool mutate_valueChange(comm::datalayer::DataChangeTrigger _valueChange) {
    return SetField<int32_t>(VT_VALUECHANGE, static_cast<int32_t>(_valueChange), 1);
  }
  bool browselistChange() const {
    return GetField<uint8_t>(VT_BROWSELISTCHANGE, 0) != 0;
  }
  bool mutate_browselistChange(bool _browselistChange) {
    return SetField<uint8_t>(VT_BROWSELISTCHANGE, static_cast<uint8_t>(_browselistChange), 0);
  }
  bool metadataChange() const {
    return GetField<uint8_t>(VT_METADATACHANGE, 0) != 0;
  }
  bool mutate_metadataChange(bool _metadataChange) {
    return SetField<uint8_t>(VT_METADATACHANGE, static_cast<uint8_t>(_metadataChange), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_VALUECHANGE) &&
           VerifyField<uint8_t>(verifier, VT_BROWSELISTCHANGE) &&
           VerifyField<uint8_t>(verifier, VT_METADATACHANGE) &&
           verifier.EndTable();
  }
  ChangeEventsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ChangeEventsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ChangeEvents> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChangeEventsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ChangeEventsBuilder {
  typedef ChangeEvents Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_valueChange(comm::datalayer::DataChangeTrigger valueChange) {
    fbb_.AddElement<int32_t>(ChangeEvents::VT_VALUECHANGE, static_cast<int32_t>(valueChange), 1);
  }
  void add_browselistChange(bool browselistChange) {
    fbb_.AddElement<uint8_t>(ChangeEvents::VT_BROWSELISTCHANGE, static_cast<uint8_t>(browselistChange), 0);
  }
  void add_metadataChange(bool metadataChange) {
    fbb_.AddElement<uint8_t>(ChangeEvents::VT_METADATACHANGE, static_cast<uint8_t>(metadataChange), 0);
  }
  explicit ChangeEventsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ChangeEvents> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ChangeEvents>(end);
    return o;
  }
};

inline flatbuffers::Offset<ChangeEvents> CreateChangeEvents(
    flatbuffers::FlatBufferBuilder &_fbb,
    comm::datalayer::DataChangeTrigger valueChange = comm::datalayer::DataChangeTrigger_StatusValue,
    bool browselistChange = false,
    bool metadataChange = false) {
  ChangeEventsBuilder builder_(_fbb);
  builder_.add_valueChange(valueChange);
  builder_.add_metadataChange(metadataChange);
  builder_.add_browselistChange(browselistChange);
  return builder_.Finish();
}

flatbuffers::Offset<ChangeEvents> CreateChangeEvents(flatbuffers::FlatBufferBuilder &_fbb, const ChangeEventsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CountingT : public flatbuffers::NativeTable {
  typedef Counting TableType;
  bool countSubscriptions = false;
};

struct Counting FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CountingT NativeTableType;
  typedef CountingBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_COUNTSUBSCRIPTIONS = 4
  };
  bool countSubscriptions() const {
    return GetField<uint8_t>(VT_COUNTSUBSCRIPTIONS, 0) != 0;
  }
  bool mutate_countSubscriptions(bool _countSubscriptions) {
    return SetField<uint8_t>(VT_COUNTSUBSCRIPTIONS, static_cast<uint8_t>(_countSubscriptions), 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_COUNTSUBSCRIPTIONS) &&
           verifier.EndTable();
  }
  CountingT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CountingT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Counting> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CountingT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CountingBuilder {
  typedef Counting Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_countSubscriptions(bool countSubscriptions) {
    fbb_.AddElement<uint8_t>(Counting::VT_COUNTSUBSCRIPTIONS, static_cast<uint8_t>(countSubscriptions), 0);
  }
  explicit CountingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Counting> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Counting>(end);
    return o;
  }
};

inline flatbuffers::Offset<Counting> CreateCounting(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool countSubscriptions = false) {
  CountingBuilder builder_(_fbb);
  builder_.add_countSubscriptions(countSubscriptions);
  return builder_.Finish();
}

flatbuffers::Offset<Counting> CreateCounting(flatbuffers::FlatBufferBuilder &_fbb, const CountingT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PropertyT : public flatbuffers::NativeTable {
  typedef Property TableType;
  comm::datalayer::PropertiesUnion rule{};
};

struct Property FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef PropertyT NativeTableType;
  typedef PropertyBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RULE_TYPE = 4,
    VT_RULE = 6
  };
  comm::datalayer::Properties rule_type() const {
    return static_cast<comm::datalayer::Properties>(GetField<uint8_t>(VT_RULE_TYPE, 0));
  }
  const void *rule() const {
    return GetPointer<const void *>(VT_RULE);
  }
  template<typename T> const T *rule_as() const;
  const comm::datalayer::Sampling *rule_as_Sampling() const {
    return rule_type() == comm::datalayer::Properties_Sampling ? static_cast<const comm::datalayer::Sampling *>(rule()) : nullptr;
  }
  const comm::datalayer::Queueing *rule_as_Queueing() const {
    return rule_type() == comm::datalayer::Properties_Queueing ? static_cast<const comm::datalayer::Queueing *>(rule()) : nullptr;
  }
  const comm::datalayer::DataChangeFilter *rule_as_DataChangeFilter() const {
    return rule_type() == comm::datalayer::Properties_DataChangeFilter ? static_cast<const comm::datalayer::DataChangeFilter *>(rule()) : nullptr;
  }
  const comm::datalayer::ChangeEvents *rule_as_ChangeEvents() const {
    return rule_type() == comm::datalayer::Properties_ChangeEvents ? static_cast<const comm::datalayer::ChangeEvents *>(rule()) : nullptr;
  }
  const comm::datalayer::Counting *rule_as_Counting() const {
    return rule_type() == comm::datalayer::Properties_Counting ? static_cast<const comm::datalayer::Counting *>(rule()) : nullptr;
  }
  void *mutable_rule() {
    return GetPointer<void *>(VT_RULE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_RULE_TYPE) &&
           VerifyOffset(verifier, VT_RULE) &&
           VerifyProperties(verifier, rule(), rule_type()) &&
           verifier.EndTable();
  }
  PropertyT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PropertyT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Property> Pack(flatbuffers::FlatBufferBuilder &_fbb, const PropertyT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const comm::datalayer::Sampling *Property::rule_as<comm::datalayer::Sampling>() const {
  return rule_as_Sampling();
}

template<> inline const comm::datalayer::Queueing *Property::rule_as<comm::datalayer::Queueing>() const {
  return rule_as_Queueing();
}

template<> inline const comm::datalayer::DataChangeFilter *Property::rule_as<comm::datalayer::DataChangeFilter>() const {
  return rule_as_DataChangeFilter();
}

template<> inline const comm::datalayer::ChangeEvents *Property::rule_as<comm::datalayer::ChangeEvents>() const {
  return rule_as_ChangeEvents();
}

template<> inline const comm::datalayer::Counting *Property::rule_as<comm::datalayer::Counting>() const {
  return rule_as_Counting();
}

struct PropertyBuilder {
  typedef Property Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rule_type(comm::datalayer::Properties rule_type) {
    fbb_.AddElement<uint8_t>(Property::VT_RULE_TYPE, static_cast<uint8_t>(rule_type), 0);
  }
  void add_rule(flatbuffers::Offset<void> rule) {
    fbb_.AddOffset(Property::VT_RULE, rule);
  }
  explicit PropertyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Property> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Property>(end);
    return o;
  }
};

inline flatbuffers::Offset<Property> CreateProperty(
    flatbuffers::FlatBufferBuilder &_fbb,
    comm::datalayer::Properties rule_type = comm::datalayer::Properties_NONE,
    flatbuffers::Offset<void> rule = 0) {
  PropertyBuilder builder_(_fbb);
  builder_.add_rule(rule);
  builder_.add_rule_type(rule_type);
  return builder_.Finish();
}

flatbuffers::Offset<Property> CreateProperty(flatbuffers::FlatBufferBuilder &_fbb, const PropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubscriptionPropertiesT : public flatbuffers::NativeTable {
  typedef SubscriptionProperties TableType;
  std::string id{};
  uint32_t keepaliveInterval = 60000;
  uint32_t publishInterval = 1000;
  std::vector<std::unique_ptr<comm::datalayer::PropertyT>> rules{};
  uint32_t errorInterval = 10000;
};

struct SubscriptionProperties FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubscriptionPropertiesT NativeTableType;
  typedef SubscriptionPropertiesBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_KEEPALIVEINTERVAL = 6,
    VT_PUBLISHINTERVAL = 8,
    VT_RULES = 10,
    VT_ERRORINTERVAL = 12
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  uint32_t keepaliveInterval() const {
    return GetField<uint32_t>(VT_KEEPALIVEINTERVAL, 60000);
  }
  bool mutate_keepaliveInterval(uint32_t _keepaliveInterval) {
    return SetField<uint32_t>(VT_KEEPALIVEINTERVAL, _keepaliveInterval, 60000);
  }
  uint32_t publishInterval() const {
    return GetField<uint32_t>(VT_PUBLISHINTERVAL, 1000);
  }
  bool mutate_publishInterval(uint32_t _publishInterval) {
    return SetField<uint32_t>(VT_PUBLISHINTERVAL, _publishInterval, 1000);
  }
  const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Property>> *rules() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Property>> *>(VT_RULES);
  }
  flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Property>> *mutable_rules() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Property>> *>(VT_RULES);
  }
  uint32_t errorInterval() const {
    return GetField<uint32_t>(VT_ERRORINTERVAL, 10000);
  }
  bool mutate_errorInterval(uint32_t _errorInterval) {
    return SetField<uint32_t>(VT_ERRORINTERVAL, _errorInterval, 10000);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<uint32_t>(verifier, VT_KEEPALIVEINTERVAL) &&
           VerifyField<uint32_t>(verifier, VT_PUBLISHINTERVAL) &&
           VerifyOffset(verifier, VT_RULES) &&
           verifier.VerifyVector(rules()) &&
           verifier.VerifyVectorOfTables(rules()) &&
           VerifyField<uint32_t>(verifier, VT_ERRORINTERVAL) &&
           verifier.EndTable();
  }
  SubscriptionPropertiesT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubscriptionPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubscriptionProperties> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubscriptionPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubscriptionPropertiesBuilder {
  typedef SubscriptionProperties Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(SubscriptionProperties::VT_ID, id);
  }
  void add_keepaliveInterval(uint32_t keepaliveInterval) {
    fbb_.AddElement<uint32_t>(SubscriptionProperties::VT_KEEPALIVEINTERVAL, keepaliveInterval, 60000);
  }
  void add_publishInterval(uint32_t publishInterval) {
    fbb_.AddElement<uint32_t>(SubscriptionProperties::VT_PUBLISHINTERVAL, publishInterval, 1000);
  }
  void add_rules(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Property>>> rules) {
    fbb_.AddOffset(SubscriptionProperties::VT_RULES, rules);
  }
  void add_errorInterval(uint32_t errorInterval) {
    fbb_.AddElement<uint32_t>(SubscriptionProperties::VT_ERRORINTERVAL, errorInterval, 10000);
  }
  explicit SubscriptionPropertiesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubscriptionProperties> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubscriptionProperties>(end);
    fbb_.Required(o, SubscriptionProperties::VT_ID);
    return o;
  }
};

inline flatbuffers::Offset<SubscriptionProperties> CreateSubscriptionProperties(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    uint32_t keepaliveInterval = 60000,
    uint32_t publishInterval = 1000,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Property>>> rules = 0,
    uint32_t errorInterval = 10000) {
  SubscriptionPropertiesBuilder builder_(_fbb);
  builder_.add_errorInterval(errorInterval);
  builder_.add_rules(rules);
  builder_.add_publishInterval(publishInterval);
  builder_.add_keepaliveInterval(keepaliveInterval);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubscriptionProperties> CreateSubscriptionPropertiesDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    uint32_t keepaliveInterval = 60000,
    uint32_t publishInterval = 1000,
    const std::vector<flatbuffers::Offset<comm::datalayer::Property>> *rules = nullptr,
    uint32_t errorInterval = 10000) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto rules__ = rules ? _fbb.CreateVector<flatbuffers::Offset<comm::datalayer::Property>>(*rules) : 0;
  return comm::datalayer::CreateSubscriptionProperties(
      _fbb,
      id__,
      keepaliveInterval,
      publishInterval,
      rules__,
      errorInterval);
}

flatbuffers::Offset<SubscriptionProperties> CreateSubscriptionProperties(flatbuffers::FlatBufferBuilder &_fbb, const SubscriptionPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline SamplingT *Sampling::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SamplingT>(new SamplingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Sampling::UnPackTo(SamplingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = samplingInterval(); _o->samplingInterval = _e; }
}

inline flatbuffers::Offset<Sampling> Sampling::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SamplingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSampling(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Sampling> CreateSampling(flatbuffers::FlatBufferBuilder &_fbb, const SamplingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SamplingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _samplingInterval = _o->samplingInterval;
  return comm::datalayer::CreateSampling(
      _fbb,
      _samplingInterval);
}

inline QueueingT *Queueing::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QueueingT>(new QueueingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Queueing::UnPackTo(QueueingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = queueSize(); _o->queueSize = _e; }
  { auto _e = behaviour(); _o->behaviour = _e; }
}

inline flatbuffers::Offset<Queueing> Queueing::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QueueingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQueueing(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Queueing> CreateQueueing(flatbuffers::FlatBufferBuilder &_fbb, const QueueingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QueueingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _queueSize = _o->queueSize;
  auto _behaviour = _o->behaviour;
  return comm::datalayer::CreateQueueing(
      _fbb,
      _queueSize,
      _behaviour);
}

inline DataChangeFilterT *DataChangeFilter::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DataChangeFilterT>(new DataChangeFilterT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void DataChangeFilter::UnPackTo(DataChangeFilterT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = deadBandValue(); _o->deadBandValue = _e; }
}

inline flatbuffers::Offset<DataChangeFilter> DataChangeFilter::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DataChangeFilterT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDataChangeFilter(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<DataChangeFilter> CreateDataChangeFilter(flatbuffers::FlatBufferBuilder &_fbb, const DataChangeFilterT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DataChangeFilterT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _deadBandValue = _o->deadBandValue;
  return comm::datalayer::CreateDataChangeFilter(
      _fbb,
      _deadBandValue);
}

inline ChangeEventsT *ChangeEvents::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ChangeEventsT>(new ChangeEventsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ChangeEvents::UnPackTo(ChangeEventsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = valueChange(); _o->valueChange = _e; }
  { auto _e = browselistChange(); _o->browselistChange = _e; }
  { auto _e = metadataChange(); _o->metadataChange = _e; }
}

inline flatbuffers::Offset<ChangeEvents> ChangeEvents::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ChangeEventsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateChangeEvents(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ChangeEvents> CreateChangeEvents(flatbuffers::FlatBufferBuilder &_fbb, const ChangeEventsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ChangeEventsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _valueChange = _o->valueChange;
  auto _browselistChange = _o->browselistChange;
  auto _metadataChange = _o->metadataChange;
  return comm::datalayer::CreateChangeEvents(
      _fbb,
      _valueChange,
      _browselistChange,
      _metadataChange);
}

inline CountingT *Counting::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CountingT>(new CountingT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Counting::UnPackTo(CountingT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = countSubscriptions(); _o->countSubscriptions = _e; }
}

inline flatbuffers::Offset<Counting> Counting::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CountingT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCounting(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Counting> CreateCounting(flatbuffers::FlatBufferBuilder &_fbb, const CountingT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CountingT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _countSubscriptions = _o->countSubscriptions;
  return comm::datalayer::CreateCounting(
      _fbb,
      _countSubscriptions);
}

inline PropertyT *Property::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PropertyT>(new PropertyT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Property::UnPackTo(PropertyT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = rule_type(); _o->rule.type = _e; }
  { auto _e = rule(); if (_e) _o->rule.value = comm::datalayer::PropertiesUnion::UnPack(_e, rule_type(), _resolver); }
}

inline flatbuffers::Offset<Property> Property::Pack(flatbuffers::FlatBufferBuilder &_fbb, const PropertyT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateProperty(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Property> CreateProperty(flatbuffers::FlatBufferBuilder &_fbb, const PropertyT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const PropertyT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _rule_type = _o->rule.type;
  auto _rule = _o->rule.Pack(_fbb);
  return comm::datalayer::CreateProperty(
      _fbb,
      _rule_type,
      _rule);
}

inline SubscriptionPropertiesT *SubscriptionProperties::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubscriptionPropertiesT>(new SubscriptionPropertiesT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubscriptionProperties::UnPackTo(SubscriptionPropertiesT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = keepaliveInterval(); _o->keepaliveInterval = _e; }
  { auto _e = publishInterval(); _o->publishInterval = _e; }
  { auto _e = rules(); if (_e) { _o->rules.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->rules[_i] = std::unique_ptr<comm::datalayer::PropertyT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = errorInterval(); _o->errorInterval = _e; }
}

inline flatbuffers::Offset<SubscriptionProperties> SubscriptionProperties::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubscriptionPropertiesT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubscriptionProperties(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubscriptionProperties> CreateSubscriptionProperties(flatbuffers::FlatBufferBuilder &_fbb, const SubscriptionPropertiesT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubscriptionPropertiesT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _keepaliveInterval = _o->keepaliveInterval;
  auto _publishInterval = _o->publishInterval;
  auto _rules = _o->rules.size() ? _fbb.CreateVector<flatbuffers::Offset<comm::datalayer::Property>> (_o->rules.size(), [](size_t i, _VectorArgs *__va) { return CreateProperty(*__va->__fbb, __va->__o->rules[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _errorInterval = _o->errorInterval;
  return comm::datalayer::CreateSubscriptionProperties(
      _fbb,
      _id,
      _keepaliveInterval,
      _publishInterval,
      _rules,
      _errorInterval);
}

inline bool VerifyProperties(flatbuffers::Verifier &verifier, const void *obj, Properties type) {
  switch (type) {
    case Properties_NONE: {
      return true;
    }
    case Properties_Sampling: {
      auto ptr = reinterpret_cast<const comm::datalayer::Sampling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Properties_Queueing: {
      auto ptr = reinterpret_cast<const comm::datalayer::Queueing *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Properties_DataChangeFilter: {
      auto ptr = reinterpret_cast<const comm::datalayer::DataChangeFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Properties_ChangeEvents: {
      auto ptr = reinterpret_cast<const comm::datalayer::ChangeEvents *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Properties_Counting: {
      auto ptr = reinterpret_cast<const comm::datalayer::Counting *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPropertiesVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyProperties(
        verifier,  values->Get(i), types->GetEnum<Properties>(i))) {
      return false;
    }
  }
  return true;
}

inline void *PropertiesUnion::UnPack(const void *obj, Properties type, const flatbuffers::resolver_function_t *resolver) {
  switch (type) {
    case Properties_Sampling: {
      auto ptr = reinterpret_cast<const comm::datalayer::Sampling *>(obj);
      return ptr->UnPack(resolver);
    }
    case Properties_Queueing: {
      auto ptr = reinterpret_cast<const comm::datalayer::Queueing *>(obj);
      return ptr->UnPack(resolver);
    }
    case Properties_DataChangeFilter: {
      auto ptr = reinterpret_cast<const comm::datalayer::DataChangeFilter *>(obj);
      return ptr->UnPack(resolver);
    }
    case Properties_ChangeEvents: {
      auto ptr = reinterpret_cast<const comm::datalayer::ChangeEvents *>(obj);
      return ptr->UnPack(resolver);
    }
    case Properties_Counting: {
      auto ptr = reinterpret_cast<const comm::datalayer::Counting *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> PropertiesUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  switch (type) {
    case Properties_Sampling: {
      auto ptr = reinterpret_cast<const comm::datalayer::SamplingT *>(value);
      return CreateSampling(_fbb, ptr, _rehasher).Union();
    }
    case Properties_Queueing: {
      auto ptr = reinterpret_cast<const comm::datalayer::QueueingT *>(value);
      return CreateQueueing(_fbb, ptr, _rehasher).Union();
    }
    case Properties_DataChangeFilter: {
      auto ptr = reinterpret_cast<const comm::datalayer::DataChangeFilterT *>(value);
      return CreateDataChangeFilter(_fbb, ptr, _rehasher).Union();
    }
    case Properties_ChangeEvents: {
      auto ptr = reinterpret_cast<const comm::datalayer::ChangeEventsT *>(value);
      return CreateChangeEvents(_fbb, ptr, _rehasher).Union();
    }
    case Properties_Counting: {
      auto ptr = reinterpret_cast<const comm::datalayer::CountingT *>(value);
      return CreateCounting(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline PropertiesUnion::PropertiesUnion(const PropertiesUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Properties_Sampling: {
      value = new comm::datalayer::SamplingT(*reinterpret_cast<comm::datalayer::SamplingT *>(u.value));
      break;
    }
    case Properties_Queueing: {
      value = new comm::datalayer::QueueingT(*reinterpret_cast<comm::datalayer::QueueingT *>(u.value));
      break;
    }
    case Properties_DataChangeFilter: {
      value = new comm::datalayer::DataChangeFilterT(*reinterpret_cast<comm::datalayer::DataChangeFilterT *>(u.value));
      break;
    }
    case Properties_ChangeEvents: {
      value = new comm::datalayer::ChangeEventsT(*reinterpret_cast<comm::datalayer::ChangeEventsT *>(u.value));
      break;
    }
    case Properties_Counting: {
      value = new comm::datalayer::CountingT(*reinterpret_cast<comm::datalayer::CountingT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void PropertiesUnion::Reset() {
  switch (type) {
    case Properties_Sampling: {
      auto ptr = reinterpret_cast<comm::datalayer::SamplingT *>(value);
      delete ptr;
      break;
    }
    case Properties_Queueing: {
      auto ptr = reinterpret_cast<comm::datalayer::QueueingT *>(value);
      delete ptr;
      break;
    }
    case Properties_DataChangeFilter: {
      auto ptr = reinterpret_cast<comm::datalayer::DataChangeFilterT *>(value);
      delete ptr;
      break;
    }
    case Properties_ChangeEvents: {
      auto ptr = reinterpret_cast<comm::datalayer::ChangeEventsT *>(value);
      delete ptr;
      break;
    }
    case Properties_Counting: {
      auto ptr = reinterpret_cast<comm::datalayer::CountingT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Properties_NONE;
}

inline const comm::datalayer::SubscriptionProperties *GetSubscriptionProperties(const void *buf) {
  return flatbuffers::GetRoot<comm::datalayer::SubscriptionProperties>(buf);
}

inline const comm::datalayer::SubscriptionProperties *GetSizePrefixedSubscriptionProperties(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<comm::datalayer::SubscriptionProperties>(buf);
}

inline SubscriptionProperties *GetMutableSubscriptionProperties(void *buf) {
  return flatbuffers::GetMutableRoot<SubscriptionProperties>(buf);
}

inline bool VerifySubscriptionPropertiesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<comm::datalayer::SubscriptionProperties>(nullptr);
}

inline bool VerifySizePrefixedSubscriptionPropertiesBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<comm::datalayer::SubscriptionProperties>(nullptr);
}

inline void FinishSubscriptionPropertiesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<comm::datalayer::SubscriptionProperties> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedSubscriptionPropertiesBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<comm::datalayer::SubscriptionProperties> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<comm::datalayer::SubscriptionPropertiesT> UnPackSubscriptionProperties(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::SubscriptionPropertiesT>(GetSubscriptionProperties(buf)->UnPack(res));
}

inline std::unique_ptr<comm::datalayer::SubscriptionPropertiesT> UnPackSizePrefixedSubscriptionProperties(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::SubscriptionPropertiesT>(GetSizePrefixedSubscriptionProperties(buf)->UnPack(res));
}

}  // namespace datalayer
}  // namespace comm

#endif  // FLATBUFFERS_GENERATED_SUBPROPERTIES_COMM_DATALAYER_H_
