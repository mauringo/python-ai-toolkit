// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_METADATA_COMM_DATALAYER_H_
#define FLATBUFFERS_GENERATED_METADATA_COMM_DATALAYER_H_

#include "flatbuffers/flatbuffers.h"

#include "allowed_operations_generated.h"

namespace comm {
namespace datalayer {

struct Extension;
struct ExtensionBuilder;
struct ExtensionT;

struct LocaleText;
struct LocaleTextBuilder;
struct LocaleTextT;

struct Reference;
struct ReferenceBuilder;
struct ReferenceT;

struct Metadata;
struct MetadataBuilder;
struct MetadataT;

enum NodeClass : int8_t {
  NodeClass_Node = 0,
  NodeClass_Method = 1,
  NodeClass_Type = 2,
  NodeClass_Variable = 3,
  NodeClass_Collection = 4,
  NodeClass_Resource = 5,
  NodeClass_Program = 6,
  NodeClass_Folder = 7,
  NodeClass_MIN = NodeClass_Node,
  NodeClass_MAX = NodeClass_Folder
};

inline const NodeClass (&EnumValuesNodeClass())[8] {
  static const NodeClass values[] = {
    NodeClass_Node,
    NodeClass_Method,
    NodeClass_Type,
    NodeClass_Variable,
    NodeClass_Collection,
    NodeClass_Resource,
    NodeClass_Program,
    NodeClass_Folder
  };
  return values;
}

inline const char * const *EnumNamesNodeClass() {
  static const char * const names[9] = {
    "Node",
    "Method",
    "Type",
    "Variable",
    "Collection",
    "Resource",
    "Program",
    "Folder",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeClass(NodeClass e) {
  if (flatbuffers::IsOutRange(e, NodeClass_Node, NodeClass_Folder)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeClass()[index];
}

enum DisplayFormat : int8_t {
  DisplayFormat_Auto = 0,
  DisplayFormat_Bin = 1,
  DisplayFormat_Oct = 2,
  DisplayFormat_Dec = 3,
  DisplayFormat_Hex = 4,
  DisplayFormat_MIN = DisplayFormat_Auto,
  DisplayFormat_MAX = DisplayFormat_Hex
};

inline const DisplayFormat (&EnumValuesDisplayFormat())[5] {
  static const DisplayFormat values[] = {
    DisplayFormat_Auto,
    DisplayFormat_Bin,
    DisplayFormat_Oct,
    DisplayFormat_Dec,
    DisplayFormat_Hex
  };
  return values;
}

inline const char * const *EnumNamesDisplayFormat() {
  static const char * const names[6] = {
    "Auto",
    "Bin",
    "Oct",
    "Dec",
    "Hex",
    nullptr
  };
  return names;
}

inline const char *EnumNameDisplayFormat(DisplayFormat e) {
  if (flatbuffers::IsOutRange(e, DisplayFormat_Auto, DisplayFormat_Hex)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDisplayFormat()[index];
}

struct ExtensionT : public flatbuffers::NativeTable {
  typedef Extension TableType;
  std::string key{};
  std::string value{};
};

struct Extension FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtensionT NativeTableType;
  typedef ExtensionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEY = 4,
    VT_VALUE = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  flatbuffers::String *mutable_key() {
    return GetPointer<flatbuffers::String *>(VT_KEY);
  }
  bool KeyCompareLessThan(const Extension *o) const {
    return *key() < *o->key();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(key()->c_str(), val);
  }
  const flatbuffers::String *value() const {
    return GetPointer<const flatbuffers::String *>(VT_VALUE);
  }
  flatbuffers::String *mutable_value() {
    return GetPointer<flatbuffers::String *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffsetRequired(verifier, VT_VALUE) &&
           verifier.VerifyString(value()) &&
           verifier.EndTable();
  }
  ExtensionT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExtensionT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Extension> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtensionT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExtensionBuilder {
  typedef Extension Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Extension::VT_KEY, key);
  }
  void add_value(flatbuffers::Offset<flatbuffers::String> value) {
    fbb_.AddOffset(Extension::VT_VALUE, value);
  }
  explicit ExtensionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Extension> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Extension>(end);
    fbb_.Required(o, Extension::VT_KEY);
    fbb_.Required(o, Extension::VT_VALUE);
    return o;
  }
};

inline flatbuffers::Offset<Extension> CreateExtension(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> value = 0) {
  ExtensionBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<Extension> CreateExtensionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *value = nullptr) {
  auto key__ = key ? _fbb.CreateString(key) : 0;
  auto value__ = value ? _fbb.CreateString(value) : 0;
  return comm::datalayer::CreateExtension(
      _fbb,
      key__,
      value__);
}

flatbuffers::Offset<Extension> CreateExtension(flatbuffers::FlatBufferBuilder &_fbb, const ExtensionT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct LocaleTextT : public flatbuffers::NativeTable {
  typedef LocaleText TableType;
  std::string id{};
  std::string text{};
};

struct LocaleText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef LocaleTextT NativeTableType;
  typedef LocaleTextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_TEXT = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  flatbuffers::String *mutable_id() {
    return GetPointer<flatbuffers::String *>(VT_ID);
  }
  bool KeyCompareLessThan(const LocaleText *o) const {
    return *id() < *o->id();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(id()->c_str(), val);
  }
  const flatbuffers::String *text() const {
    return GetPointer<const flatbuffers::String *>(VT_TEXT);
  }
  flatbuffers::String *mutable_text() {
    return GetPointer<flatbuffers::String *>(VT_TEXT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffsetRequired(verifier, VT_TEXT) &&
           verifier.VerifyString(text()) &&
           verifier.EndTable();
  }
  LocaleTextT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(LocaleTextT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<LocaleText> Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocaleTextT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct LocaleTextBuilder {
  typedef LocaleText Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(LocaleText::VT_ID, id);
  }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) {
    fbb_.AddOffset(LocaleText::VT_TEXT, text);
  }
  explicit LocaleTextBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<LocaleText> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocaleText>(end);
    fbb_.Required(o, LocaleText::VT_ID);
    fbb_.Required(o, LocaleText::VT_TEXT);
    return o;
  }
};

inline flatbuffers::Offset<LocaleText> CreateLocaleText(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  LocaleTextBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<LocaleText> CreateLocaleTextDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *text = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto text__ = text ? _fbb.CreateString(text) : 0;
  return comm::datalayer::CreateLocaleText(
      _fbb,
      id__,
      text__);
}

flatbuffers::Offset<LocaleText> CreateLocaleText(flatbuffers::FlatBufferBuilder &_fbb, const LocaleTextT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ReferenceT : public flatbuffers::NativeTable {
  typedef Reference TableType;
  std::string type{};
  std::string targetAddress{};
};

struct Reference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ReferenceT NativeTableType;
  typedef ReferenceBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_TARGETADDRESS = 6
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  flatbuffers::String *mutable_type() {
    return GetPointer<flatbuffers::String *>(VT_TYPE);
  }
  bool KeyCompareLessThan(const Reference *o) const {
    return *type() < *o->type();
  }
  int KeyCompareWithValue(const char *val) const {
    return strcmp(type()->c_str(), val);
  }
  const flatbuffers::String *targetAddress() const {
    return GetPointer<const flatbuffers::String *>(VT_TARGETADDRESS);
  }
  flatbuffers::String *mutable_targetAddress() {
    return GetPointer<flatbuffers::String *>(VT_TARGETADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffsetRequired(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffsetRequired(verifier, VT_TARGETADDRESS) &&
           verifier.VerifyString(targetAddress()) &&
           verifier.EndTable();
  }
  ReferenceT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ReferenceT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Reference> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ReferenceBuilder {
  typedef Reference Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Reference::VT_TYPE, type);
  }
  void add_targetAddress(flatbuffers::Offset<flatbuffers::String> targetAddress) {
    fbb_.AddOffset(Reference::VT_TARGETADDRESS, targetAddress);
  }
  explicit ReferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Reference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reference>(end);
    fbb_.Required(o, Reference::VT_TYPE);
    fbb_.Required(o, Reference::VT_TARGETADDRESS);
    return o;
  }
};

inline flatbuffers::Offset<Reference> CreateReference(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> targetAddress = 0) {
  ReferenceBuilder builder_(_fbb);
  builder_.add_targetAddress(targetAddress);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reference> CreateReferenceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *targetAddress = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto targetAddress__ = targetAddress ? _fbb.CreateString(targetAddress) : 0;
  return comm::datalayer::CreateReference(
      _fbb,
      type__,
      targetAddress__);
}

flatbuffers::Offset<Reference> CreateReference(flatbuffers::FlatBufferBuilder &_fbb, const ReferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MetadataT : public flatbuffers::NativeTable {
  typedef Metadata TableType;
  comm::datalayer::NodeClass nodeClass = comm::datalayer::NodeClass_Node;
  std::unique_ptr<comm::datalayer::AllowedOperationsT> operations{};
  std::string description{};
  std::string descriptionUrl{};
  std::string displayName{};
  comm::datalayer::DisplayFormat displayFormat = comm::datalayer::DisplayFormat_Auto;
  std::string unit{};
  std::vector<std::unique_ptr<comm::datalayer::ExtensionT>> extensions{};
  std::vector<std::unique_ptr<comm::datalayer::ReferenceT>> references{};
  std::vector<std::unique_ptr<comm::datalayer::LocaleTextT>> descriptions{};
  std::vector<std::unique_ptr<comm::datalayer::LocaleTextT>> displayNames{};
};

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataT NativeTableType;
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODECLASS = 4,
    VT_OPERATIONS = 6,
    VT_DESCRIPTION = 8,
    VT_DESCRIPTIONURL = 10,
    VT_DISPLAYNAME = 12,
    VT_DISPLAYFORMAT = 14,
    VT_UNIT = 16,
    VT_EXTENSIONS = 18,
    VT_REFERENCES = 20,
    VT_DESCRIPTIONS = 22,
    VT_DISPLAYNAMES = 24
  };
  comm::datalayer::NodeClass nodeClass() const {
    return static_cast<comm::datalayer::NodeClass>(GetField<int8_t>(VT_NODECLASS, 0));
  }
  bool mutate_nodeClass(comm::datalayer::NodeClass _nodeClass) {
    return SetField<int8_t>(VT_NODECLASS, static_cast<int8_t>(_nodeClass), 0);
  }
  const comm::datalayer::AllowedOperations *operations() const {
    return GetPointer<const comm::datalayer::AllowedOperations *>(VT_OPERATIONS);
  }
  comm::datalayer::AllowedOperations *mutable_operations() {
    return GetPointer<comm::datalayer::AllowedOperations *>(VT_OPERATIONS);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  flatbuffers::String *mutable_description() {
    return GetPointer<flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::String *descriptionUrl() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTIONURL);
  }
  flatbuffers::String *mutable_descriptionUrl() {
    return GetPointer<flatbuffers::String *>(VT_DESCRIPTIONURL);
  }
  const flatbuffers::String *displayName() const {
    return GetPointer<const flatbuffers::String *>(VT_DISPLAYNAME);
  }
  flatbuffers::String *mutable_displayName() {
    return GetPointer<flatbuffers::String *>(VT_DISPLAYNAME);
  }
  comm::datalayer::DisplayFormat displayFormat() const {
    return static_cast<comm::datalayer::DisplayFormat>(GetField<int8_t>(VT_DISPLAYFORMAT, 0));
  }
  bool mutate_displayFormat(comm::datalayer::DisplayFormat _displayFormat) {
    return SetField<int8_t>(VT_DISPLAYFORMAT, static_cast<int8_t>(_displayFormat), 0);
  }
  const flatbuffers::String *unit() const {
    return GetPointer<const flatbuffers::String *>(VT_UNIT);
  }
  flatbuffers::String *mutable_unit() {
    return GetPointer<flatbuffers::String *>(VT_UNIT);
  }
  const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Extension>> *extensions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Extension>> *>(VT_EXTENSIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Extension>> *mutable_extensions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Extension>> *>(VT_EXTENSIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Reference>> *references() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Reference>> *>(VT_REFERENCES);
  }
  flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Reference>> *mutable_references() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Reference>> *>(VT_REFERENCES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *descriptions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *>(VT_DESCRIPTIONS);
  }
  flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *mutable_descriptions() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *>(VT_DESCRIPTIONS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *displayNames() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *>(VT_DISPLAYNAMES);
  }
  flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *mutable_displayNames() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *>(VT_DISPLAYNAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_NODECLASS) &&
           VerifyOffsetRequired(verifier, VT_OPERATIONS) &&
           verifier.VerifyTable(operations()) &&
           VerifyOffsetRequired(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffsetRequired(verifier, VT_DESCRIPTIONURL) &&
           verifier.VerifyString(descriptionUrl()) &&
           VerifyOffset(verifier, VT_DISPLAYNAME) &&
           verifier.VerifyString(displayName()) &&
           VerifyField<int8_t>(verifier, VT_DISPLAYFORMAT) &&
           VerifyOffset(verifier, VT_UNIT) &&
           verifier.VerifyString(unit()) &&
           VerifyOffset(verifier, VT_EXTENSIONS) &&
           verifier.VerifyVector(extensions()) &&
           verifier.VerifyVectorOfTables(extensions()) &&
           VerifyOffset(verifier, VT_REFERENCES) &&
           verifier.VerifyVector(references()) &&
           verifier.VerifyVectorOfTables(references()) &&
           VerifyOffset(verifier, VT_DESCRIPTIONS) &&
           verifier.VerifyVector(descriptions()) &&
           verifier.VerifyVectorOfTables(descriptions()) &&
           VerifyOffset(verifier, VT_DISPLAYNAMES) &&
           verifier.VerifyVector(displayNames()) &&
           verifier.VerifyVectorOfTables(displayNames()) &&
           verifier.EndTable();
  }
  MetadataT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Metadata> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MetadataBuilder {
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeClass(comm::datalayer::NodeClass nodeClass) {
    fbb_.AddElement<int8_t>(Metadata::VT_NODECLASS, static_cast<int8_t>(nodeClass), 0);
  }
  void add_operations(flatbuffers::Offset<comm::datalayer::AllowedOperations> operations) {
    fbb_.AddOffset(Metadata::VT_OPERATIONS, operations);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(Metadata::VT_DESCRIPTION, description);
  }
  void add_descriptionUrl(flatbuffers::Offset<flatbuffers::String> descriptionUrl) {
    fbb_.AddOffset(Metadata::VT_DESCRIPTIONURL, descriptionUrl);
  }
  void add_displayName(flatbuffers::Offset<flatbuffers::String> displayName) {
    fbb_.AddOffset(Metadata::VT_DISPLAYNAME, displayName);
  }
  void add_displayFormat(comm::datalayer::DisplayFormat displayFormat) {
    fbb_.AddElement<int8_t>(Metadata::VT_DISPLAYFORMAT, static_cast<int8_t>(displayFormat), 0);
  }
  void add_unit(flatbuffers::Offset<flatbuffers::String> unit) {
    fbb_.AddOffset(Metadata::VT_UNIT, unit);
  }
  void add_extensions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Extension>>> extensions) {
    fbb_.AddOffset(Metadata::VT_EXTENSIONS, extensions);
  }
  void add_references(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Reference>>> references) {
    fbb_.AddOffset(Metadata::VT_REFERENCES, references);
  }
  void add_descriptions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>>> descriptions) {
    fbb_.AddOffset(Metadata::VT_DESCRIPTIONS, descriptions);
  }
  void add_displayNames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>>> displayNames) {
    fbb_.AddOffset(Metadata::VT_DISPLAYNAMES, displayNames);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    fbb_.Required(o, Metadata::VT_OPERATIONS);
    fbb_.Required(o, Metadata::VT_DESCRIPTION);
    fbb_.Required(o, Metadata::VT_DESCRIPTIONURL);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    comm::datalayer::NodeClass nodeClass = comm::datalayer::NodeClass_Node,
    flatbuffers::Offset<comm::datalayer::AllowedOperations> operations = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::String> descriptionUrl = 0,
    flatbuffers::Offset<flatbuffers::String> displayName = 0,
    comm::datalayer::DisplayFormat displayFormat = comm::datalayer::DisplayFormat_Auto,
    flatbuffers::Offset<flatbuffers::String> unit = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Extension>>> extensions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::Reference>>> references = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>>> descriptions = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<comm::datalayer::LocaleText>>> displayNames = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_displayNames(displayNames);
  builder_.add_descriptions(descriptions);
  builder_.add_references(references);
  builder_.add_extensions(extensions);
  builder_.add_unit(unit);
  builder_.add_displayName(displayName);
  builder_.add_descriptionUrl(descriptionUrl);
  builder_.add_description(description);
  builder_.add_operations(operations);
  builder_.add_displayFormat(displayFormat);
  builder_.add_nodeClass(nodeClass);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    comm::datalayer::NodeClass nodeClass = comm::datalayer::NodeClass_Node,
    flatbuffers::Offset<comm::datalayer::AllowedOperations> operations = 0,
    const char *description = nullptr,
    const char *descriptionUrl = nullptr,
    const char *displayName = nullptr,
    comm::datalayer::DisplayFormat displayFormat = comm::datalayer::DisplayFormat_Auto,
    const char *unit = nullptr,
    std::vector<flatbuffers::Offset<comm::datalayer::Extension>> *extensions = nullptr,
    std::vector<flatbuffers::Offset<comm::datalayer::Reference>> *references = nullptr,
    std::vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *descriptions = nullptr,
    std::vector<flatbuffers::Offset<comm::datalayer::LocaleText>> *displayNames = nullptr) {
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto descriptionUrl__ = descriptionUrl ? _fbb.CreateString(descriptionUrl) : 0;
  auto displayName__ = displayName ? _fbb.CreateString(displayName) : 0;
  auto unit__ = unit ? _fbb.CreateString(unit) : 0;
  auto extensions__ = extensions ? _fbb.CreateVectorOfSortedTables<comm::datalayer::Extension>(extensions) : 0;
  auto references__ = references ? _fbb.CreateVectorOfSortedTables<comm::datalayer::Reference>(references) : 0;
  auto descriptions__ = descriptions ? _fbb.CreateVectorOfSortedTables<comm::datalayer::LocaleText>(descriptions) : 0;
  auto displayNames__ = displayNames ? _fbb.CreateVectorOfSortedTables<comm::datalayer::LocaleText>(displayNames) : 0;
  return comm::datalayer::CreateMetadata(
      _fbb,
      nodeClass,
      operations,
      description__,
      descriptionUrl__,
      displayName__,
      displayFormat,
      unit__,
      extensions__,
      references__,
      descriptions__,
      displayNames__);
}

flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ExtensionT *Extension::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExtensionT>(new ExtensionT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Extension::UnPackTo(ExtensionT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = key(); if (_e) _o->key = _e->str(); }
  { auto _e = value(); if (_e) _o->value = _e->str(); }
}

inline flatbuffers::Offset<Extension> Extension::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtensionT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExtension(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Extension> CreateExtension(flatbuffers::FlatBufferBuilder &_fbb, const ExtensionT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExtensionT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _key = _fbb.CreateString(_o->key);
  auto _value = _fbb.CreateString(_o->value);
  return comm::datalayer::CreateExtension(
      _fbb,
      _key,
      _value);
}

inline LocaleTextT *LocaleText::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<LocaleTextT>(new LocaleTextT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void LocaleText::UnPackTo(LocaleTextT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = id(); if (_e) _o->id = _e->str(); }
  { auto _e = text(); if (_e) _o->text = _e->str(); }
}

inline flatbuffers::Offset<LocaleText> LocaleText::Pack(flatbuffers::FlatBufferBuilder &_fbb, const LocaleTextT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateLocaleText(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<LocaleText> CreateLocaleText(flatbuffers::FlatBufferBuilder &_fbb, const LocaleTextT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const LocaleTextT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _id = _fbb.CreateString(_o->id);
  auto _text = _fbb.CreateString(_o->text);
  return comm::datalayer::CreateLocaleText(
      _fbb,
      _id,
      _text);
}

inline ReferenceT *Reference::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ReferenceT>(new ReferenceT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Reference::UnPackTo(ReferenceT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = targetAddress(); if (_e) _o->targetAddress = _e->str(); }
}

inline flatbuffers::Offset<Reference> Reference::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ReferenceT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateReference(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Reference> CreateReference(flatbuffers::FlatBufferBuilder &_fbb, const ReferenceT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ReferenceT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _fbb.CreateString(_o->type);
  auto _targetAddress = _fbb.CreateString(_o->targetAddress);
  return comm::datalayer::CreateReference(
      _fbb,
      _type,
      _targetAddress);
}

inline MetadataT *Metadata::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MetadataT>(new MetadataT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Metadata::UnPackTo(MetadataT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = nodeClass(); _o->nodeClass = _e; }
  { auto _e = operations(); if (_e) _o->operations = std::unique_ptr<comm::datalayer::AllowedOperationsT>(_e->UnPack(_resolver)); }
  { auto _e = description(); if (_e) _o->description = _e->str(); }
  { auto _e = descriptionUrl(); if (_e) _o->descriptionUrl = _e->str(); }
  { auto _e = displayName(); if (_e) _o->displayName = _e->str(); }
  { auto _e = displayFormat(); _o->displayFormat = _e; }
  { auto _e = unit(); if (_e) _o->unit = _e->str(); }
  { auto _e = extensions(); if (_e) { _o->extensions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->extensions[_i] = std::unique_ptr<comm::datalayer::ExtensionT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = references(); if (_e) { _o->references.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->references[_i] = std::unique_ptr<comm::datalayer::ReferenceT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = descriptions(); if (_e) { _o->descriptions.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->descriptions[_i] = std::unique_ptr<comm::datalayer::LocaleTextT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = displayNames(); if (_e) { _o->displayNames.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->displayNames[_i] = std::unique_ptr<comm::datalayer::LocaleTextT>(_e->Get(_i)->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<Metadata> Metadata::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMetadata(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Metadata> CreateMetadata(flatbuffers::FlatBufferBuilder &_fbb, const MetadataT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MetadataT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _nodeClass = _o->nodeClass;
  auto _operations = _o->operations ? CreateAllowedOperations(_fbb, _o->operations.get(), _rehasher) : 0;
  auto _description = _fbb.CreateString(_o->description);
  auto _descriptionUrl = _fbb.CreateString(_o->descriptionUrl);
  auto _displayName = _o->displayName.empty() ? 0 : _fbb.CreateString(_o->displayName);
  auto _displayFormat = _o->displayFormat;
  auto _unit = _o->unit.empty() ? 0 : _fbb.CreateString(_o->unit);
  auto _extensions = _o->extensions.size() ? _fbb.CreateVector<flatbuffers::Offset<comm::datalayer::Extension>> (_o->extensions.size(), [](size_t i, _VectorArgs *__va) { return CreateExtension(*__va->__fbb, __va->__o->extensions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _references = _o->references.size() ? _fbb.CreateVector<flatbuffers::Offset<comm::datalayer::Reference>> (_o->references.size(), [](size_t i, _VectorArgs *__va) { return CreateReference(*__va->__fbb, __va->__o->references[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _descriptions = _o->descriptions.size() ? _fbb.CreateVector<flatbuffers::Offset<comm::datalayer::LocaleText>> (_o->descriptions.size(), [](size_t i, _VectorArgs *__va) { return CreateLocaleText(*__va->__fbb, __va->__o->descriptions[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _displayNames = _o->displayNames.size() ? _fbb.CreateVector<flatbuffers::Offset<comm::datalayer::LocaleText>> (_o->displayNames.size(), [](size_t i, _VectorArgs *__va) { return CreateLocaleText(*__va->__fbb, __va->__o->displayNames[i].get(), __va->__rehasher); }, &_va ) : 0;
  return comm::datalayer::CreateMetadata(
      _fbb,
      _nodeClass,
      _operations,
      _description,
      _descriptionUrl,
      _displayName,
      _displayFormat,
      _unit,
      _extensions,
      _references,
      _descriptions,
      _displayNames);
}

inline const comm::datalayer::Metadata *GetMetadata(const void *buf) {
  return flatbuffers::GetRoot<comm::datalayer::Metadata>(buf);
}

inline const comm::datalayer::Metadata *GetSizePrefixedMetadata(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<comm::datalayer::Metadata>(buf);
}

inline Metadata *GetMutableMetadata(void *buf) {
  return flatbuffers::GetMutableRoot<Metadata>(buf);
}

inline bool VerifyMetadataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<comm::datalayer::Metadata>(nullptr);
}

inline bool VerifySizePrefixedMetadataBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<comm::datalayer::Metadata>(nullptr);
}

inline void FinishMetadataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<comm::datalayer::Metadata> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMetadataBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<comm::datalayer::Metadata> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<comm::datalayer::MetadataT> UnPackMetadata(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::MetadataT>(GetMetadata(buf)->UnPack(res));
}

inline std::unique_ptr<comm::datalayer::MetadataT> UnPackSizePrefixedMetadata(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<comm::datalayer::MetadataT>(GetSizePrefixedMetadata(buf)->UnPack(res));
}

}  // namespace datalayer
}  // namespace comm

#endif  // FLATBUFFERS_GENERATED_METADATA_COMM_DATALAYER_H_
